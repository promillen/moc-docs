# Firmware Development Guide

This guide provides essential information for firmware developers working on IoT devices that communicate with the MOC-IoT system. It covers Protocol Buffer integration, CoAP implementation, and testing procedures.

## Getting Started

### Prerequisites

- **C/C++ Development Environment**: Embedded toolchain for your target hardware
- **Protocol Buffer Compiler**: `protoc` for generating C code from .proto files
- **CoAP Library**: Recommended libraries for CoAP client implementation
- **Testing Tools**: For validating messages before deployment

### Required Libraries

#### Protocol Buffers for C
```bash
# Install protobuf-c (for embedded C development)
git clone https://github.com/protobuf-c/protobuf-c.git
cd protobuf-c
./configure && make && make install

# Alternative: Use nanopb for smaller footprint
git clone https://github.com/nanopb/nanopb.git
```

#### CoAP Libraries
- **libcoap** (full-featured): `https://github.com/obgm/libcoap`
- **microcoap** (minimal): `https://github.com/1248/microcoap`
- **cantcoap** (Arduino-compatible): `https://github.com/staropram/cantcoap`

## Protocol Buffer Integration

### Generating C Code from Proto Files

The MOC-IoT system uses these proto definitions:

```bash
# Download proto files from the system
curl -O https://raw.githubusercontent.com/your-repo/CoAP-bridge/main/Protobuf/uplink.proto

# Generate C code using nanopb (recommended for embedded)
python3 nanopb/generator/nanopb_generator.py uplink.proto

# This generates:
# - uplink.pb.h (header file)
# - uplink.pb.c (implementation file)
```

### Include Generated Files in Your Project

```c
// main.c - Include generated protobuf files
#include "uplink.pb.h"
#include <pb_encode.h>
#include <pb_decode.h>
```

## Message Construction

### Basic Heartbeat Message

```c
#include "uplink.pb.h"
#include <pb_encode.h>
#include <string.h>

// Global message counter
static uint32_t message_counter = 0;

bool create_heartbeat_message(uint8_t* buffer, size_t buffer_size, size_t* message_length) {
    uplink_Uplink uplink = uplink_Uplink_init_zero;
    
    // Set message counter (increment with each transmission)
    uplink.uplink_count = ++message_counter;
    uplink.has_uplink_count = true;
    
    // Configure device information
    uplink.has_heartbeat = true;
    uplink.heartbeat.has_config = true;
    
    // Device identification
    uplink.heartbeat.config.dev_id = 12345;  // Your unique device ID
    uplink.heartbeat.config.has_dev_id = true;
    
    // Communication settings  
    uplink.heartbeat.config.heartbeat_interval = 3600;  // 1 hour in seconds
    uplink.heartbeat.config.has_heartbeat_interval = true;
    
    // SIM card information
    strcpy(uplink.heartbeat.config.iccid, "89461177711234567890");
    
    // Version information
    strcpy(uplink.heartbeat.config.hw_version, "v1.2.3");
    strcpy(uplink.heartbeat.config.sw_version, "v2.0.1"); 
    
    // Location mode setting
    uplink.heartbeat.config.location_mode = uplink_LocationMode_GNSS_WIFI;
    uplink.heartbeat.config.has_location_mode = true;
    
    // Power consumption data
    uplink.heartbeat.has_activity = true;
    uplink.heartbeat.activity.sleep = 3540;     // 59 minutes in sleep mode
    uplink.heartbeat.activity.has_sleep = true;
    uplink.heartbeat.activity.modem = 45;       // 45 seconds modem active
    uplink.heartbeat.activity.has_modem = true;
    uplink.heartbeat.activity.gnss = 10;        // 10 seconds GNSS active  
    uplink.heartbeat.activity.has_gnss = true;
    uplink.heartbeat.activity.wifi = 5;         // 5 seconds WiFi scanning
    uplink.heartbeat.activity.has_wifi = true;
    
    // Modem temperature (optional)
    uplink.heartbeat.modem_temperature = 42;    // Celsius
    uplink.heartbeat.has_modem_temperature = true;
    
    // Encode the message
    pb_ostream_t stream = pb_ostream_from_buffer(buffer, buffer_size);
    bool status = pb_encode(&stream, uplink_Uplink_fields, &uplink);
    
    if (status) {
        *message_length = stream.bytes_written;
        return true;
    }
    
    return false;
}
```

### Adding Location Data (WiFi Scanning)

```c
bool create_location_message(uint8_t* buffer, size_t buffer_size, size_t* message_length) {
    uplink_Uplink uplink = uplink_Uplink_init_zero;
    
    uplink.uplink_count = ++message_counter;
    uplink.has_uplink_count = true;
    
    // Add WiFi access point data
    uplink.has_location = true;
    uplink.location.wifi_count = 0;  // Will be incremented as we add APs
    
    // Example: Add detected WiFi access points
    if (uplink.location.wifi_count < uplink_WiFi_count) {
        strcpy(uplink.location.wifi[0].mac, "AA:BB:CC:DD:EE:FF");
        uplink.location.wifi[0].rssi = -45;  // Signal strength in dBm
        uplink.location.wifi[0].has_rssi = true;
        uplink.location.wifi_count++;
    }
    
    if (uplink.location.wifi_count < uplink_WiFi_count) {
        strcpy(uplink.location.wifi[1].mac, "11:22:33:44:55:66");
        uplink.location.wifi[1].rssi = -67;
        uplink.location.wifi[1].has_rssi = true;
        uplink.location.wifi_count++;
    }
    
    // Include device ID for identification
    uplink.has_heartbeat = true;
    uplink.heartbeat.has_config = true;
    uplink.heartbeat.config.dev_id = 12345;
    uplink.heartbeat.config.has_dev_id = true;
    
    // Encode message
    pb_ostream_t stream = pb_ostream_from_buffer(buffer, buffer_size);
    bool status = pb_encode(&stream, uplink_Uplink_fields, &uplink);
    
    if (status) {
        *message_length = stream.bytes_written;
        return true;
    }
    
    return false;
}
```

### Reboot Information

```c
void set_reboot_info(uplink_Uplink* uplink, uplink_RebootReason reason, 
                     const char* file, uint32_t line) {
    uplink->has_heartbeat = true;
    uplink->heartbeat.has_reboot = true;
    
    uplink->heartbeat.reboot.reason = reason;
    uplink->heartbeat.reboot.has_reason = true;
    
    if (file) {
        strncpy(uplink->heartbeat.reboot.file, file, sizeof(uplink->heartbeat.reboot.file) - 1);
        uplink->heartbeat.reboot.file[sizeof(uplink->heartbeat.reboot.file) - 1] = '\0';
    }
    
    uplink->heartbeat.reboot.line = line;
    uplink->heartbeat.reboot.has_line = true;
}

// Usage example
uplink_Uplink uplink = uplink_Uplink_init_zero;
set_reboot_info(&uplink, uplink_RebootReason_SOFTWARE, __FILE__, __LINE__);
```

## CoAP Client Implementation

### Basic CoAP Client

```c
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

// CoAP server configuration
#define COAP_SERVER "flyio-nbiot.fly.dev"
#define COAP_PORT 5683
#define COAP_URI_PATH "/data"

// Simple CoAP message structure (simplified)
typedef struct {
    uint8_t ver_type_tkl;       // Version, Type, Token Length
    uint8_t code;               // Method/Response Code
    uint16_t message_id;        // Message ID
    uint8_t token[8];           // Token (optional)
    uint8_t* payload;           // Payload data
    size_t payload_len;         // Payload length
} coap_message_t;

// CoAP POST method code
#define COAP_CODE_POST 0x02

bool send_coap_message(uint8_t* data, size_t data_len) {
    int sockfd;
    struct sockaddr_in server_addr;
    
    // Create UDP socket
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd < 0) {
        return false;
    }
    
    // Configure server address
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(COAP_PORT);
    inet_pton(AF_INET, COAP_SERVER_IP, &server_addr.sin_addr);  // Use resolved IP
    
    // Build CoAP message
    uint8_t coap_buffer[512];
    size_t coap_len = build_coap_post(coap_buffer, sizeof(coap_buffer), 
                                     COAP_URI_PATH, data, data_len);
    
    if (coap_len == 0) {
        close(sockfd);
        return false;
    }
    
    // Send message
    ssize_t sent = sendto(sockfd, coap_buffer, coap_len, 0, 
                         (struct sockaddr*)&server_addr, sizeof(server_addr));
    
    if (sent != coap_len) {
        close(sockfd);
        return false;
    }
    
    // Optionally wait for response
    uint8_t response[256];
    socklen_t addr_len = sizeof(server_addr);
    ssize_t received = recvfrom(sockfd, response, sizeof(response), 0,
                               (struct sockaddr*)&server_addr, &addr_len);
    
    close(sockfd);
    
    // Check response code (2.04 Changed = success)
    if (received > 1 && response[1] == 0x44) {  // 2.04 Changed
        return true;
    }
    
    return false;
}
```

### Complete Message Transmission Example

```c
#include "coap_client.h"
#include "uplink.pb.h"

// Main transmission function
bool transmit_device_data(void) {
    uint8_t message_buffer[256];
    size_t message_length;
    
    // Create heartbeat message
    if (!create_heartbeat_message(message_buffer, sizeof(message_buffer), &message_length)) {
        printf("Failed to encode protobuf message\n");
        return false;
    }
    
    printf("Encoded message: %zu bytes\n", message_length);
    
    // Send via CoAP
    if (!send_coap_message(message_buffer, message_length)) {
        printf("Failed to send CoAP message\n");
        return false;
    }
    
    printf("Message sent successfully\n");
    return true;
}

// Application main loop
int main() {
    // Initialize hardware, cellular modem, etc.
    
    while (1) {
        // Collect sensor data
        // Scan WiFi networks
        // Get system status
        
        // Transmit data
        if (transmit_device_data()) {
            printf("Data transmission successful\n");
        } else {
            printf("Data transmission failed\n");
        }
        
        // Sleep until next transmission interval
        sleep(3600);  // 1 hour
    }
    
    return 0;
}
```

## WiFi Scanning Integration

### WiFi MAC Address Collection

```c
#include <wifilib.h>  // Your WiFi library

typedef struct {
    char mac[18];       // "AA:BB:CC:DD:EE:FF\0"
    int32_t rssi;       // Signal strength
} wifi_ap_t;

#define MAX_WIFI_APS 10

int scan_wifi_networks(wifi_ap_t* networks, int max_networks) {
    // Initialize WiFi scanning
    wifi_init();
    
    // Start scan
    wifi_scan_start();
    
    // Wait for scan completion
    while (!wifi_scan_done()) {
        delay(100);
    }
    
    // Get results
    int found_networks = wifi_get_scan_results(networks, max_networks);
    
    // Power down WiFi to save energy
    wifi_deinit();
    
    return found_networks;
}

// Usage in message creation
bool add_wifi_data_to_message(uplink_Uplink* uplink) {
    wifi_ap_t networks[MAX_WIFI_APS];
    int network_count = scan_wifi_networks(networks, MAX_WIFI_APS);
    
    if (network_count <= 0) {
        return false;  // No networks found
    }
    
    uplink->has_location = true;
    uplink->location.wifi_count = 0;
    
    for (int i = 0; i < network_count && i < uplink_WiFi_count; i++) {
        strcpy(uplink->location.wifi[i].mac, networks[i].mac);
        uplink->location.wifi[i].rssi = networks[i].rssi;
        uplink->location.wifi[i].has_rssi = true;
        uplink->location.wifi_count++;
    }
    
    return true;
}
```

## Error Handling and Retry Logic

### Robust Message Transmission

```c
#define MAX_RETRIES 3
#define RETRY_DELAY_MS 5000

typedef enum {
    TRANSMIT_SUCCESS = 0,
    TRANSMIT_ENCODE_ERROR = 1,
    TRANSMIT_NETWORK_ERROR = 2,
    TRANSMIT_SERVER_ERROR = 3,
    TRANSMIT_TIMEOUT = 4
} transmit_result_t;

transmit_result_t transmit_with_retry(void) {
    int retries = MAX_RETRIES;
    
    while (retries > 0) {
        uint8_t message_buffer[256];
        size_t message_length;
        
        // Create message
        if (!create_heartbeat_message(message_buffer, sizeof(message_buffer), &message_length)) {
            return TRANSMIT_ENCODE_ERROR;  // Don't retry encoding errors
        }
        
        // Attempt transmission
        coap_result_t coap_result = send_coap_message(message_buffer, message_length);
        
        switch (coap_result) {
            case COAP_SUCCESS:
                return TRANSMIT_SUCCESS;
                
            case COAP_BAD_REQUEST:
                return TRANSMIT_SERVER_ERROR;  // Don't retry client errors
                
            case COAP_TIMEOUT:
            case COAP_NETWORK_ERROR:
                retries--;
                if (retries > 0) {
                    printf("Transmission failed, retrying in %d seconds...\n", RETRY_DELAY_MS / 1000);
                    delay(RETRY_DELAY_MS);
                }
                break;
                
            default:
                return TRANSMIT_SERVER_ERROR;
        }
    }
    
    return TRANSMIT_TIMEOUT;
}
```

## Testing and Validation

### Message Validation Tools

Create a simple validation program to test your messages locally:

```c
// test_messages.c
#include "uplink.pb.h"
#include <pb_decode.h>
#include <stdio.h>

bool validate_message(uint8_t* buffer, size_t length) {
    uplink_Uplink uplink = uplink_Uplink_init_zero;
    
    pb_istream_t stream = pb_istream_from_buffer(buffer, length);
    bool decode_status = pb_decode(&stream, uplink_Uplink_fields, &uplink);
    
    if (!decode_status) {
        printf("Decode failed: %s\n", PB_GET_ERROR(&stream));
        return false;
    }
    
    // Validate required fields
    if (!uplink.has_uplink_count) {
        printf("Missing uplink_count\n");
        return false;
    }
    
    if (uplink.has_heartbeat && uplink.heartbeat.has_config) {
        if (!uplink.heartbeat.config.has_dev_id) {
            printf("Missing device ID\n");
            return false;
        }
        printf("Device ID: %u\n", uplink.heartbeat.config.dev_id);
    }
    
    if (uplink.has_location && uplink.location.wifi_count > 0) {
        printf("WiFi networks: %u\n", uplink.location.wifi_count);
        for (int i = 0; i < uplink.location.wifi_count; i++) {
            printf("  AP %d: %s (RSSI: %d)\n", i, 
                   uplink.location.wifi[i].mac, 
                   uplink.location.wifi[i].rssi);
        }
    }
    
    printf("Message validation successful\n");
    return true;
}

int main() {
    uint8_t test_buffer[256];
    size_t test_length;
    
    // Create test message
    if (create_heartbeat_message(test_buffer, sizeof(test_buffer), &test_length)) {
        printf("Created message: %zu bytes\n", test_length);
        
        // Validate the message
        validate_message(test_buffer, test_length);
        
        // Print hex dump for debugging
        printf("Hex dump: ");
        for (size_t i = 0; i < test_length; i++) {
            printf("%02x ", test_buffer[i]);
        }
        printf("\n");
    }
    
    return 0;
}
```

### Testing Against Local Server

You can test your firmware against a local Python server for debugging:

```python
#!/usr/bin/env python3
# test_server.py - Local test server

import asyncio
import aiocoap.resource as resource
import aiocoap
import uplink_pb2

class TestDataResource(resource.Resource):
    def __init__(self):
        super().__init__()

    async def render_post(self, request):
        try:
            print(f"Received {len(request.payload)} bytes")
            print(f"Hex: {request.payload.hex()}")
            
            # Try to decode protobuf
            uplink = uplink_pb2.Uplink()
            uplink.ParseFromString(request.payload)
            print(f"Decoded message: {uplink}")
            
            return aiocoap.Message(code=aiocoap.CHANGED)
        except Exception as e:
            print(f"Error: {e}")
            return aiocoap.Message(code=aiocoap.BAD_REQUEST)

async def main():
    root = resource.Site()
    root.add_resource(['data'], TestDataResource())
    
    await aiocoap.Context.create_server_context(root, bind=('localhost', 5683))
    print("Test server running on localhost:5683")
    
    # Keep running
    await asyncio.get_running_loop().create_future()

if __name__ == "__main__":
    asyncio.run(main())
```

Run the test server and point your firmware to `localhost:5683` for testing.

## Best Practices

### Power Management
- **Minimize Transmission Frequency**: Send heartbeats only when necessary
- **Batch Data**: Combine multiple sensor readings in one message
- **WiFi Scanning**: Limit scan time and frequency to save battery
- **Error Handling**: Don't retry indefinitely on failures

### Message Design
- **Include Device ID**: Always include device identification in messages
- **Version Information**: Send firmware version for debugging
- **Message Counters**: Use uplink_count to detect lost messages
- **Timestamp Data**: Include timestamps for event correlation

### Network Reliability
- **Retry Logic**: Implement exponential backoff for retries
- **Connection Timeout**: Set appropriate timeouts for cellular networks  
- **Graceful Degradation**: Continue operation if server is unreachable
- **Status Indicators**: Provide feedback on transmission success/failure

### Debugging and Monitoring
- **Verbose Logging**: Log message creation and transmission details
- **Test Messages**: Validate messages locally before deployment
- **Network Monitoring**: Track cellular connection quality
- **Battery Monitoring**: Monitor power consumption patterns