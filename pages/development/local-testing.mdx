# Local Testing Environment

This guide explains how to set up a local testing environment for developing and debugging MOC-IoT firmware and backend components.

## Testing Architecture Overview

```
Local Testing Setup:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Firmware Device ‚îÇ    ‚îÇ Local CoAP Server‚îÇ    ‚îÇ Local Dashboard ‚îÇ
‚îÇ (or Simulator)  ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ Python Test      ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ React Dev       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ Server           ‚îÇ    ‚îÇ Server          ‚îÇ
                       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
                              ‚ñº
                       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                       ‚îÇ Supabase        ‚îÇ
                       ‚îÇ (Development)   ‚îÇ
                       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Setting Up Local CoAP Server

### Python Test Server

Create a local CoAP server that mimics the production Fly.io server:

```python
#!/usr/bin/env python3
# local_coap_server.py

import asyncio
import logging
import colorlog
import aiocoap.resource as resource
import aiocoap
import json
from typing import Dict, Any
import sys
import os

# Add the CoAP-bridge directory to Python path
sys.path.append('../CoAP-bridge')

import uplink_pb2
from store_to_supabase import SupabaseClient

# Setup colored logging
handler = colorlog.StreamHandler()
handler.setFormatter(colorlog.ColoredFormatter(
    "%(log_color)s[%(asctime)s] %(levelname)s - %(message)s",
    datefmt="%H:%M:%S",
    log_colors={
        "DEBUG":    "cyan",
        "INFO":     "green", 
        "WARNING":  "yellow",
        "ERROR":    "red",
        "CRITICAL": "bold_red",
    }
))

logger = colorlog.getLogger()
logger.setLevel(logging.DEBUG)
logger.handlers.clear()
logger.addHandler(handler)

class LocalDataResource(resource.Resource):
    def __init__(self, enable_supabase=True):
        super().__init__()
        self.enable_supabase = enable_supabase
        if enable_supabase:
            try:
                self.supabase_client = SupabaseClient()
                logger.info("‚úÖ Supabase client initialized")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Supabase client failed to initialize: {e}")
                logger.warning("üìù Running in local-only mode")
                self.enable_supabase = False

    async def render_post(self, request):
        try:
            logger.info(f"üì® Received CoAP message: {len(request.payload)} bytes")
            logger.debug(f"üîç Raw hex: {request.payload.hex()}")
            
            # Parse protobuf message
            uplink = uplink_pb2.Uplink()
            uplink.ParseFromString(request.payload)
            
            logger.info(f"‚úÖ Successfully parsed protobuf message")
            
            # Log message details
            self.log_message_details(uplink)
            
            # Forward to Supabase if enabled
            if self.enable_supabase:
                await self.forward_to_supabase(uplink)
            
            return aiocoap.Message(code=aiocoap.CHANGED)
            
        except Exception as e:
            logger.error(f"‚ùå Error processing message: {e}")
            return aiocoap.Message(code=aiocoap.BAD_REQUEST)

    def log_message_details(self, uplink: uplink_pb2.Uplink):
        """Log detailed message information for debugging"""
        
        logger.info(f"üìä Message Details:")
        logger.info(f"   Uplink Count: {uplink.uplink_count}")
        
        if uplink.HasField('heartbeat'):
            hb = uplink.heartbeat
            logger.info(f"üíì Heartbeat Message:")
            
            if hb.HasField('config'):
                config = hb.config
                logger.info(f"   üì± Device ID: {config.dev_id}")
                logger.info(f"   ‚è±Ô∏è Heartbeat Interval: {config.heartbeat_interval}s")
                logger.info(f"   üì∂ ICCID: {config.iccid}")
                logger.info(f"   üîß HW Version: {config.hw_version}")
                logger.info(f"   üíæ SW Version: {config.sw_version}")
                logger.info(f"   üìç Location Mode: {uplink_pb2.LocationMode.Name(config.location_mode)}")
            
            if hb.HasField('activity'):
                activity = hb.activity
                logger.info(f"   ‚ö° Power Activity:")
                logger.info(f"      Sleep: {activity.sleep}s")
                logger.info(f"      Modem: {activity.modem}s") 
                logger.info(f"      GNSS: {activity.gnss}s")
                logger.info(f"      WiFi: {activity.wifi}s")
                logger.info(f"      Other: {activity.other}s")
            
            if hb.HasField('reboot'):
                reboot = hb.reboot
                reason_name = uplink_pb2.RebootReason.Name(reboot.reason)
                logger.info(f"   üîÑ Reboot: {reason_name}")
                if reboot.file:
                    logger.info(f"      File: {reboot.file}:{reboot.line}")
            
            if hb.HasField('modem_temperature'):
                logger.info(f"   üå°Ô∏è Modem Temperature: {hb.modem_temperature}¬∞C")
        
        if uplink.HasField('location'):
            location = uplink.location
            logger.info(f"üìç Location Data:")
            logger.info(f"   WiFi Networks: {len(location.wifi)}")
            
            for i, wifi in enumerate(location.wifi):
                logger.info(f"      AP {i+1}: {wifi.mac} (RSSI: {wifi.rssi} dBm)")

    async def forward_to_supabase(self, uplink: uplink_pb2.Uplink):
        """Forward parsed message to Supabase (mirrors production behavior)"""
        try:
            # Convert protobuf to JSON format (similar to main.py)
            json_data = self.protobuf_to_json(uplink)
            
            logger.info(f"üì§ Forwarding to Supabase: {len(json.dumps(json_data))} bytes")
            logger.debug(f"üîç JSON payload: {json.dumps(json_data, indent=2)}")
            
            # Here you would call the actual Supabase storage functions
            # For now, just log the conversion
            logger.info(f"‚úÖ Would forward to Supabase successfully")
            
        except Exception as e:
            logger.error(f"‚ùå Supabase forwarding failed: {e}")

    def protobuf_to_json(self, uplink: uplink_pb2.Uplink) -> Dict[str, Any]:
        """Convert protobuf message to JSON format"""
        data = {
            "uplink_count": uplink.uplink_count,
            "timestamp": "2024-01-01T00:00:00Z"  # Would be current time
        }
        
        if uplink.HasField('heartbeat'):
            hb = uplink.heartbeat
            data["heartbeat"] = {}
            
            if hb.HasField('config'):
                data["heartbeat"]["config"] = {
                    "dev_id": hb.config.dev_id,
                    "heartbeat_interval": hb.config.heartbeat_interval,
                    "iccid": hb.config.iccid,
                    "hw_version": hb.config.hw_version,
                    "sw_version": hb.config.sw_version,
                    "location_mode": uplink_pb2.LocationMode.Name(hb.config.location_mode)
                }
            
            if hb.HasField('activity'):
                data["heartbeat"]["activity"] = {
                    "sleep": hb.activity.sleep,
                    "modem": hb.activity.modem,
                    "gnss": hb.activity.gnss,
                    "wifi": hb.activity.wifi,
                    "other": hb.activity.other
                }
        
        if uplink.HasField('location'):
            data["location"] = {
                "wifi": [
                    {"mac": wifi.mac, "rssi": wifi.rssi}
                    for wifi in uplink.location.wifi
                ]
            }
        
        return data

async def main():
    """Start the local CoAP test server"""
    
    # Configuration
    enable_supabase = os.getenv('ENABLE_SUPABASE', 'false').lower() == 'true'
    port = int(os.getenv('COAP_PORT', '5683'))
    
    logger.info(f"üöÄ Starting Local CoAP Test Server")
    logger.info(f"üì° Port: {port}")
    logger.info(f"üóÑÔ∏è Supabase forwarding: {'enabled' if enable_supabase else 'disabled'}")
    
    # Create resource
    root = resource.Site()
    root.add_resource(['data'], LocalDataResource(enable_supabase=enable_supabase))
    
    # Start server
    await aiocoap.Context.create_server_context(root, bind=('localhost', port))
    logger.info(f"‚úÖ Local CoAP server running on localhost:{port}")
    logger.info(f"üìù Ready to receive messages at coap://localhost:{port}/data")
    
    # Keep server running
    try:
        await asyncio.get_running_loop().create_future()
    except KeyboardInterrupt:
        logger.info("üõë Server stopped by user")

if __name__ == "__main__":
    asyncio.run(main())
```

### Running the Local Server

```bash
# Navigate to docs directory
cd "C:\Programming Projects\MOC-IoT\Docs"

# Install dependencies
pip install aiocoap colorlog protobuf

# Set environment variables (optional)
export ENABLE_SUPABASE=true
export SUPABASE_URL="https://cdwtsrzshpotkfbyyyjk.supabase.co"
export SUPABASE_API_KEY="your_service_key_here"

# Run the server
python3 local_coap_server.py
```

## Firmware Testing Tools

### CoAP Client Testing Tool

Create a tool to send test messages without actual hardware:

```python
#!/usr/bin/env python3
# test_client.py

import asyncio
import aiocoap
import uplink_pb2
import argparse
import json

async def send_test_message(server_host="localhost", server_port=5683, message_type="heartbeat"):
    """Send a test message to the CoAP server"""
    
    # Create test message
    uplink = uplink_pb2.Uplink()
    uplink.uplink_count = 42
    
    if message_type == "heartbeat":
        create_heartbeat_test(uplink)
    elif message_type == "location":
        create_location_test(uplink)
    elif message_type == "combined":
        create_heartbeat_test(uplink)
        create_location_test(uplink)
    
    # Serialize message
    payload = uplink.SerializeToString()
    print(f"üì¶ Created {message_type} message: {len(payload)} bytes")
    
    # Create CoAP client context
    context = await aiocoap.Context.create_client_context()
    
    # Build request
    uri = f"coap://{server_host}:{server_port}/data"
    request = aiocoap.Message(code=aiocoap.POST, payload=payload, uri=uri)
    
    try:
        print(f"üì° Sending to {uri}...")
        response = await context.request(request).response
        print(f"‚úÖ Response: {response.code} ({response.code.name})")
        
        if response.payload:
            print(f"üìÑ Response payload: {response.payload.decode('utf-8', errors='ignore')}")
            
    except Exception as e:
        print(f"‚ùå Error: {e}")
    
    await context.shutdown()

def create_heartbeat_test(uplink):
    """Create a test heartbeat message"""
    uplink.heartbeat.config.dev_id = 12345
    uplink.heartbeat.config.heartbeat_interval = 3600
    uplink.heartbeat.config.iccid = "89461177711234567890"
    uplink.heartbeat.config.hw_version = "v1.2.3"
    uplink.heartbeat.config.sw_version = "v2.0.1-test"
    uplink.heartbeat.config.location_mode = uplink_pb2.LocationMode.GNSS_WIFI
    
    uplink.heartbeat.activity.sleep = 3540
    uplink.heartbeat.activity.modem = 45
    uplink.heartbeat.activity.gnss = 10
    uplink.heartbeat.activity.wifi = 5
    uplink.heartbeat.activity.other = 0
    
    uplink.heartbeat.modem_temperature = 42

def create_location_test(uplink):
    """Create a test location message"""
    # Add test WiFi networks
    wifi1 = uplink.location.wifi.add()
    wifi1.mac = "AA:BB:CC:DD:EE:FF"
    wifi1.rssi = -45
    
    wifi2 = uplink.location.wifi.add()
    wifi2.mac = "11:22:33:44:55:66"
    wifi2.rssi = -67
    
    wifi3 = uplink.location.wifi.add()
    wifi3.mac = "99:88:77:66:55:44"
    wifi3.rssi = -78

async def main():
    parser = argparse.ArgumentParser(description='CoAP Test Client')
    parser.add_argument('--host', default='localhost', help='CoAP server host')
    parser.add_argument('--port', type=int, default=5683, help='CoAP server port')
    parser.add_argument('--type', choices=['heartbeat', 'location', 'combined'], 
                       default='heartbeat', help='Message type to send')
    parser.add_argument('--count', type=int, default=1, help='Number of messages to send')
    parser.add_argument('--interval', type=float, default=1.0, help='Interval between messages (seconds)')
    
    args = parser.parse_args()
    
    print(f"üß™ CoAP Test Client")
    print(f"üéØ Target: {args.host}:{args.port}")
    print(f"üìù Message type: {args.type}")
    print(f"üî¢ Count: {args.count}")
    
    for i in range(args.count):
        if args.count > 1:
            print(f"\nüì® Sending message {i+1}/{args.count}")
        
        await send_test_message(args.host, args.port, args.type)
        
        if i < args.count - 1:
            await asyncio.sleep(args.interval)

if __name__ == "__main__":
    asyncio.run(main())
```

### Usage Examples

```bash
# Send a single heartbeat message
python3 test_client.py

# Send location data
python3 test_client.py --type location

# Send combined message
python3 test_client.py --type combined

# Send multiple messages to test throughput
python3 test_client.py --count 10 --interval 0.5

# Test against production server (use carefully!)
python3 test_client.py --host flyio-nbiot.fly.dev --type heartbeat
```

## Message Analysis Tools

### Protobuf Message Inspector

```python
#!/usr/bin/env python3
# message_inspector.py

import uplink_pb2
import sys
import json
from google.protobuf.json_format import MessageToJson

def inspect_message_file(filename):
    """Inspect a binary protobuf message file"""
    try:
        with open(filename, 'rb') as f:
            data = f.read()
        
        print(f"üìÅ File: {filename}")
        print(f"üìè Size: {len(data)} bytes")
        print(f"üîç Hex dump:")
        print("   " + " ".join(f"{b:02x}" for b in data))
        print()
        
        # Parse protobuf
        uplink = uplink_pb2.Uplink()
        uplink.ParseFromString(data)
        
        print("‚úÖ Successfully parsed protobuf message")
        print()
        
        # Convert to JSON for readable output
        json_str = MessageToJson(uplink, preserving_proto_field_name=True)
        json_obj = json.loads(json_str)
        print("üìã Message content:")
        print(json.dumps(json_obj, indent=2))
        
        # Analyze message
        analyze_message(uplink)
        
    except FileNotFoundError:
        print(f"‚ùå File not found: {filename}")
    except Exception as e:
        print(f"‚ùå Error: {e}")

def analyze_message(uplink):
    """Analyze message for common issues"""
    print("\nüîç Message Analysis:")
    
    issues = []
    
    # Check required fields
    if not uplink.HasField('uplink_count'):
        issues.append("Missing uplink_count")
    
    if uplink.HasField('heartbeat'):
        hb = uplink.heartbeat
        if hb.HasField('config'):
            if not hb.config.HasField('dev_id'):
                issues.append("Missing device ID in config")
            if hb.config.dev_id == 0:
                issues.append("Device ID is zero")
        else:
            issues.append("Heartbeat message missing config")
    
    if uplink.HasField('location'):
        if len(uplink.location.wifi) == 0:
            issues.append("Location message has no WiFi data")
        
        for i, wifi in enumerate(uplink.location.wifi):
            if not wifi.mac:
                issues.append(f"WiFi AP {i+1} missing MAC address")
            if wifi.rssi == 0:
                issues.append(f"WiFi AP {i+1} has zero RSSI")
            if wifi.rssi > -10:
                issues.append(f"WiFi AP {i+1} RSSI seems too high: {wifi.rssi}")
    
    if issues:
        print("‚ö†Ô∏è Issues found:")
        for issue in issues:
            print(f"   - {issue}")
    else:
        print("‚úÖ No issues detected")

def create_test_file(filename, message_type="heartbeat"):
    """Create a test message file for debugging"""
    uplink = uplink_pb2.Uplink()
    uplink.uplink_count = 123
    
    if message_type in ["heartbeat", "combined"]:
        uplink.heartbeat.config.dev_id = 12345
        uplink.heartbeat.config.heartbeat_interval = 3600
        uplink.heartbeat.config.iccid = "89461177711234567890"
        uplink.heartbeat.config.hw_version = "v1.0"
        uplink.heartbeat.config.sw_version = "v2.0-test"
        uplink.heartbeat.config.location_mode = uplink_pb2.LocationMode.WIFI_GNSS
        
        uplink.heartbeat.activity.sleep = 3500
        uplink.heartbeat.activity.modem = 80
        uplink.heartbeat.activity.wifi = 15
        uplink.heartbeat.activity.gnss = 5
        
        uplink.heartbeat.reboot.reason = uplink_pb2.RebootReason.POWER_ON
        uplink.heartbeat.modem_temperature = 38
    
    if message_type in ["location", "combined"]:
        wifi1 = uplink.location.wifi.add()
        wifi1.mac = "AA:BB:CC:DD:EE:FF"
        wifi1.rssi = -45
        
        wifi2 = uplink.location.wifi.add()
        wifi2.mac = "11:22:33:44:55:66"
        wifi2.rssi = -67
    
    # Write to file
    with open(filename, 'wb') as f:
        f.write(uplink.SerializeToString())
    
    print(f"‚úÖ Created test file: {filename}")

def main():
    if len(sys.argv) < 2:
        print("Usage:")
        print("  python3 message_inspector.py <message_file.bin>")
        print("  python3 message_inspector.py --create <output_file.bin> [heartbeat|location|combined]")
        return
    
    if sys.argv[1] == "--create":
        if len(sys.argv) < 3:
            print("‚ùå Please specify output filename")
            return
        filename = sys.argv[2]
        message_type = sys.argv[3] if len(sys.argv) > 3 else "heartbeat"
        create_test_file(filename, message_type)
        inspect_message_file(filename)  # Also inspect the created file
    else:
        inspect_message_file(sys.argv[1])

if __name__ == "__main__":
    main()
```

### Usage Examples

```bash
# Create and inspect test messages
python3 message_inspector.py --create test_heartbeat.bin heartbeat
python3 message_inspector.py --create test_location.bin location
python3 message_inspector.py --create test_combined.bin combined

# Inspect existing message files
python3 message_inspector.py captured_message.bin

# Compare messages
python3 message_inspector.py message1.bin > analysis1.txt
python3 message_inspector.py message2.bin > analysis2.txt
diff analysis1.txt analysis2.txt
```

## Dashboard Local Development

### Setting up Local Dashboard

```bash
# Navigate to dashboard directory
cd "C:\Programming Projects\MOC-IoT\Dashboard"

# Install dependencies
npm install

# Start development server (connects to Supabase)
npm run dev

# Dashboard will be available at http://localhost:8080
```

### Environment Configuration for Testing

Create a `.env.local` file in the Dashboard directory:

```bash
# .env.local
VITE_SUPABASE_URL=https://cdwtsrzshpotkfbyyyjk.supabase.co
VITE_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

# Optional: Enable debug logging
VITE_DEBUG=true
```

## Complete Testing Workflow

### 1. Start Local Services

```bash
# Terminal 1: Start local CoAP server
cd "C:\Programming Projects\MOC-IoT\Docs"
python3 local_coap_server.py

# Terminal 2: Start dashboard
cd "C:\Programming Projects\MOC-IoT\Dashboard"
npm run dev
```

### 2. Test Message Flow

```bash
# Terminal 3: Send test messages
cd "C:\Programming Projects\MOC-IoT\Docs"

# Send heartbeat
python3 test_client.py --type heartbeat

# Send location data
python3 test_client.py --type location

# Send multiple messages
python3 test_client.py --type combined --count 5 --interval 2.0
```

### 3. Validate Results

1. **CoAP Server Logs**: Check that messages are received and parsed correctly
2. **Dashboard**: Verify that device data appears in the dashboard (if Supabase enabled)
3. **Database**: Query Supabase directly to confirm data storage

## Debugging Common Issues

### Connection Problems

```bash
# Check if CoAP server is running
netstat -an | grep 5683

# Test basic UDP connectivity
nc -u localhost 5683

# Use tcpdump to monitor CoAP traffic
sudo tcpdump -i lo -A port 5683
```

### Protobuf Issues

```bash
# Validate protobuf schema
protoc --decode=uplink.Uplink uplink.proto < test_message.bin

# Check generated Python files are up to date
protoc --python_out=. uplink.proto
diff uplink_pb2.py ../CoAP-bridge/uplink_pb2.py
```

### Supabase Connectivity

```python
# test_supabase.py - Test database connection
import os
from supabase import create_client, Client

url = os.environ.get("SUPABASE_URL")
key = os.environ.get("SUPABASE_API_KEY")

supabase = create_client(url, key)

# Test query
try:
    result = supabase.table('device_config').select("*").limit(1).execute()
    print(f"‚úÖ Supabase connection successful")
    print(f"üìä Sample data: {result.data}")
except Exception as e:
    print(f"‚ùå Supabase connection failed: {e}")
```

This local testing environment allows you to develop and debug both firmware and backend components without affecting the production system.