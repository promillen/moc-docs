# Protocol Overview

This page provides a high-level overview of the communication protocols used in the MOC-IoT system.

## CoAP Protocol

### Why CoAP?

**CoAP (Constrained Application Protocol)** is designed specifically for IoT devices with limited resources:

- **Lightweight**: Minimal protocol overhead for battery-powered devices
- **UDP-based**: No connection setup overhead, ideal for intermittent connectivity
- **Low bandwidth**: Critical for NB-IoT cellular networks with limited data
- **RESTful design**: Familiar HTTP-like semantics (GET, POST, PUT, DELETE)
- **Built-in reliability**: Optional confirmable messages with automatic retries

### Endpoint Configuration

**Production Server**:
- Host: `flyio-nbiot.fly.dev`
- Port: `5683` (UDP)
- Protocol: CoAP (RFC 7252)
- Method: `POST`
- Path: `/data`
- Content-Type: `application/octet-stream`

### Message Transaction Flow

1. **Encoding**: Device encodes data using Protocol Buffers
2. **Transmission**: Device sends CoAP POST to `/data` endpoint over UDP
3. **Reception**: Fly.io server receives and validates protobuf message
4. **Processing**: Server parses message and forwards to Supabase
5. **Acknowledgment**: Server sends CoAP ACK back to device
6. **Future**: Optional downlink responses (configuration updates, commands)

### CoAP Message Types

**Confirmable (CON)**:
- Requires acknowledgment from server
- Automatic retries if no ACK received
- Used for critical data transmission

**Non-Confirmable (NON)**:
- Fire-and-forget messages
- No acknowledgment required
- Lower overhead, suitable for frequent updates

**Acknowledgment (ACK)**:
- Response to confirmable messages
- Can include payload (piggybacked response)

## Protocol Buffers

### Why Protocol Buffers?

**Protocol Buffers** (protobuf) is Google's language-neutral data serialization format, chosen for:

- **Compact size**: 3-10x smaller than equivalent JSON
- **Type safety**: Strong typing prevents runtime errors
- **Schema evolution**: Backward and forward compatibility
- **Cross-language**: Code generation for C, Python, TypeScript, etc.
- **Validation**: Built-in field presence and type checking

### Message Structure Hierarchy

```
Uplink (root message)
├── uplink_count: uint32 (message counter)
├── Heartbeat (device status)
│   ├── Config (device configuration)
│   ├── Activity (power consumption)
│   ├── Reboot (system events)
│   ├── internal_temperature: uint32
│   └── internal_voltage: uint32
├── ExternalSensor (sensor measurements)
│   └── external_sensor: string (flexible JSON format)
└── Location (positioning data)
    ├── CellTower (cellular tower)
    └── WiFi[] (access points, repeated)
```

### Key Protobuf Concepts

**Field Numbers**:
- Unique identifier for each field (not the value)
- Once assigned, never change (breaks compatibility)
- Used for compact binary encoding

**Optional vs Required**:
- All fields are optional in proto3
- Use `has_field` checks to determine presence
- Allows for flexible message composition

**Enumerations**:
- Type-safe constants (e.g., `LocationMode`, `RebootReason`)
- Default value is always `0`
- Can add new values without breaking compatibility

**Repeated Fields**:
- Arrays of values (e.g., `repeated WiFi wifi`)
- Variable-length lists
- Efficient binary encoding

## Complete Protobuf Schema

### Uplink Messages (Device → Server)

The complete protocol buffer definition for device uplink messages:

```protobuf
syntax = "proto3";
package uplink;

enum LocationMode {
  NONE = 0;
  CELL_TOWER = 1;
  GNSS = 2;
  WIFI = 3;
}

message Config {
  uint32 dev_id = 1;
  uint32 heartbeat_interval = 2;
  string iccid = 3;
  string hw_version = 4;
  string sw_version = 5;
  string apn = 6;
  uint32 band = 7;
  LocationMode location_mode = 8;
}

message Activity {
  uint32 sleep = 1;
  uint32 modem = 2;
  uint32 gnss = 3;
  uint32 wifi = 4;
  uint32 other = 5;
}

enum RebootReason {
  UNKNOWN = 0;
  SOFTWARE = 1;
  ASSERT = 2;
  RTC_WAKEUP = 3;
  POWER_ON = 4;
  WATCHDOG = 5;
}

message Reboot {
  RebootReason reason = 1;
  string file = 2;
  uint32 line = 3;
}

message Heartbeat {
  Config config = 1;
  Activity activity = 2;
  Reboot reboot = 3;
  uint32 internal_temperature = 4;
  uint32 internal_voltage = 5;
}

message CellTower {
  uint32 mcc = 1;
  uint32 mnc = 2;
  uint32 tac = 3;
  uint32 cell_id = 4;
  uint32 act = 5;
}

message WiFi {
  string mac = 1;
  sint32 rssi = 2;
}

message Location {
  CellTower cell_tower = 1;
  repeated WiFi wifi = 2;
}

message ExternalSensor {
  string external_sensor = 1;
}

message Uplink {
  Heartbeat heartbeat = 1;
  ExternalSensor external_sensor = 2;
  Location location = 3;
  uint32 uplink_count = 4;
}
```

### Downlink Messages (Server → Device)

The protocol buffer definition for server downlink messages:

```protobuf
syntax = "proto3";
package downlink;

enum LocationMode {
  NONE = 0;
  CELL_TOWER = 1;
  GNSS = 2;
  WIFI = 3;
}

message Config {
  uint32 heartbeat_interval = 1;
  LocationMode location_mode = 2;
}

message FUOTA {
  string sw_version = 1;
  string checksum = 2;
}

message Downlink {
  Config config = 1;
  FUOTA fuota = 2;
}
```

### Example Uplink Message (JSON Representation)

When decoded from protobuf, an uplink message looks like this in JSON format:

```json
{
  "uplink": {
    "heartbeat": {
      "config": {
        "dev_id": 10000,
        "heartbeat_interval": 720,
        "iccid": "89012345678901234567",
        "hw_version": "0.1",
        "sw_version": "2025.04",
        "apn": "lpwa.telia.iot",
        "band": 20,
        "location_mode": 1
      },
      "activity": {
        "sleep": 0,
        "modem": 0,
        "gnss": 0,
        "wifi": 0,
        "other": 0
      },
      "reboot": {
        "reason": 0,
        "file": "file.bin",
        "line": 1
      },
      "internal_temperature": 25,
      "internal_voltage": 3600
    },
    "external_sensor": {
      "sensor": "temp:1,hum:2,con:2.5"
    },
    "location": {
      "cell_tower": {
        "mcc": 240,
        "mnc": 5,
        "tac": 12345,
        "cell_id": 67890,
        "act": 2
      },
      "wifi": [
        {
          "mac": "001122334455",
          "rssi": -70
        }
      ]
    },
    "uplink_count": 1
  }
}
```

### Field Descriptions

**Heartbeat.Config**:
- `dev_id`: Unique device identifier (numeric)
- `heartbeat_interval`: Seconds between status updates (e.g., 720 = 12 minutes)
- `iccid`: SIM card identifier (20 digits)
- `hw_version`: Hardware revision (string, e.g., "0.1")
- `sw_version`: Firmware version (string, e.g., "2025.04")
- `apn`: Cellular APN for data connection (e.g., "lpwa.telia.iot")
- `band`: LTE frequency band number (e.g., 20 = 800MHz)
- `location_mode`: Positioning method (0=NONE, 1=CELL_TOWER, 2=GNSS, 3=WIFI)

**Heartbeat.Activity**:
- All fields in seconds, representing time spent in each power state
- `sleep`: Low-power sleep mode
- `modem`: Cellular modem active
- `gnss`: GPS/GNSS positioning active
- `wifi`: WiFi scanning active
- `other`: Miscellaneous operations

**Heartbeat.Reboot**:
- `reason`: Reboot cause (0=UNKNOWN, 1=SOFTWARE, 2=ASSERT, 3=RTC_WAKEUP, 4=POWER_ON, 5=WATCHDOG)
- `file`: Source file where crash occurred (if applicable)
- `line`: Line number in source file (if applicable)

**Heartbeat**:
- `internal_temperature`: Modem temperature in Celsius
- `internal_voltage`: Battery voltage in millivolts (e.g., 3600 = 3.6V)

**ExternalSensor**:
- `sensor`: Flexible string format for sensor data (e.g., "temp:25.5,hum:60")

**Location.CellTower**:
- `mcc`: Mobile Country Code (e.g., 240 for Sweden)
- `mnc`: Mobile Network Code (e.g., 5 for Telia)
- `tac`: Tracking Area Code
- `cell_id`: Cell tower identifier
- `act`: Access technology (0=GSM, 1=UTRAN, 2=LTE)

**Location.WiFi** (repeated):
- `mac`: WiFi access point MAC address (12 hex digits)
- `rssi`: Signal strength in dBm (negative value, e.g., -70)

**Uplink**:
- `uplink_count`: Sequential message counter, increments with each transmission

## Message Categories

The system processes three primary message categories:

### 1. Heartbeat Messages

**Purpose**: Periodic device status updates

**Contains**:
- Device identification (dev_id, ICCID)
- Configuration settings (heartbeat interval, location mode)
- Firmware versions (hardware, software)
- Activity tracking (sleep, modem, GNSS, WiFi usage)
- System events (reboot reasons, diagnostics)
- Battery level and modem temperature

**Frequency**: Configurable (default 1 hour)

**Processing**: Direct storage in database, no external API calls

### 2. Location Messages

**Purpose**: Device positioning and movement tracking

**Contains**:
- WiFi access points (MAC addresses, RSSI)
- Cellular towers (MCC, MNC, LAC, CID)
- GNSS coordinates (latitude, longitude, accuracy)

**Frequency**: On-demand or periodic based on location mode

**Processing**:
- WiFi/Cellular: Sent to HERE Positioning API for triangulation
- GNSS: Direct coordinate validation and storage

### 3. Sensor Data Messages

**Purpose**: Domain-specific measurements

**Contains**:
- Environmental data (temperature, humidity, pressure)
- Soil metrics (moisture, pH, NPK levels)
- Custom sensor readings (extensible JSONB)

**Frequency**: Varies by sensor type and sampling rate

**Processing**: Direct validation and storage, real-time dashboard updates

## Data Encoding Pipeline

### Device Side (Firmware)

```
Sensor Reading → Protobuf Structure → Binary Encoding → CoAP Message → UDP Transmission
```

1. Collect sensor data or device status
2. Populate protobuf message structure in memory
3. Encode to compact binary format
4. Wrap in CoAP POST request
5. Transmit via UDP over NB-IoT

### Server Side (Fly.io)

```
UDP Reception → CoAP Parsing → Protobuf Decoding → JSON Transform → HMAC Signing → HTTPS Forward
```

1. Receive UDP packet on port 5683
2. Parse CoAP headers and payload
3. Decode protobuf binary to structured data
4. Convert to JSON format for Supabase
5. Calculate HMAC signature
6. Forward via HTTPS to Edge Function

### Backend Side (Supabase)

```
HTTPS Reception → HMAC Verification → Data Routing → API Integration → Database Storage → WebSocket Push
```

1. Receive HTTPS POST from Fly.io
2. Verify HMAC signature authenticity
3. Route by data type (location vs sensor)
4. Call HERE API if location data present
5. Store in appropriate database table
6. Push real-time updates to dashboard

## Protocol Evolution

### Version Compatibility

Protocol Buffers ensures backward compatibility:

**Adding Fields**:
- New optional fields can be added freely
- Old firmware ignores new fields
- New server handles messages from old firmware

**Removing Fields**:
- Mark as deprecated, don't reuse field numbers
- Server continues to accept old messages
- Gradual migration as devices update

**Changing Types**:
- Avoid type changes (breaks compatibility)
- Add new field with new type if needed
- Deprecate old field

### Schema Update Process

1. Update `.proto` file in repository
2. Regenerate code for all platforms:
   - Firmware: `nanopb` for embedded C
   - Server: `protoc` for Python
   - Dashboard: `protoc` for TypeScript (if needed)
3. Deploy server first (handles both old and new)
4. Update firmware gradually via OTA
5. Monitor for parsing errors in logs

## Security Considerations

### Protocol-Level Security

**CoAP**:
- No built-in encryption for messages
- Relies on cellular network encryption (LTE/NB-IoT)
- Optional DTLS support (not currently implemented)

**Protobuf**:
- Provides data validation, not encryption
- Schema prevents malformed messages
- Type checking reduces injection attacks

### System-Level Security

**Device Authentication**:
- Device ID in protobuf payload
- Whitelisted devices in database
- Cellular network provides device isolation

**Server-to-Server**:
- HMAC-SHA256 signatures on all Fly.io → Supabase requests
- TLS encryption for HTTPS traffic
- Environment-based secret management

**Data Integrity**:
- Protobuf schema validation
- HMAC prevents message tampering
- Database constraints enforce data quality

## Performance Characteristics

### Message Size Comparison

**Heartbeat Message**:
- Protobuf: ~80-120 bytes
- Equivalent JSON: ~300-400 bytes
- **Savings**: ~70% reduction

**Location Message** (10 WiFi networks):
- Protobuf: ~200-250 bytes
- Equivalent JSON: ~800-1000 bytes
- **Savings**: ~75% reduction

### Latency Benchmarks

**Device to Server** (CoAP):
- Typical: 200-500ms (NB-IoT latency)
- Maximum: 2000ms (poor network conditions)

**Server to Database** (HTTPS):
- Typical: 50-150ms (Fly.io → Supabase)
- With HERE API: +200-400ms (location processing)

**Database to Dashboard** (WebSocket):
- Typical: 10-50ms (real-time subscription)
- Updates appear within 1 second of device transmission

### Bandwidth Usage

**Per Message**:
- CoAP overhead: ~20 bytes
- Protobuf payload: 80-250 bytes
- **Total**: 100-270 bytes per transmission

**Monthly Estimate** (hourly heartbeat):
- Messages per month: 720 (24 × 30)
- Data usage: ~180 KB/month
- Well within NB-IoT plan limits

## Future Protocol Enhancements

### Planned Features

**Downlink Commands**:
- Remote configuration updates
- OTA firmware deployment
- Device reboot/reset commands

**DTLS Encryption**:
- End-to-end encryption for CoAP
- Certificate-based device authentication
- Enhanced security for sensitive data

**Message Compression**:
- GZIP compression for large payloads
- Further bandwidth reduction
- Trade-off: increased processing time

**Multicast Support**:
- Broadcast messages to device groups
- Efficient configuration updates
- Firmware distribution optimization
